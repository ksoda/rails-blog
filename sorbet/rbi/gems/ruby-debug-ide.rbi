# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ruby-debug-ide/all/ruby-debug-ide.rbi
#
# ruby-debug-ide-0.7.2

module Debase
  def self._start_control_common(host, port, socket_path, notify_dispatcher); end
  def self._start_server_common(host, port, socket_path, notify_dispatcher); end
  def self.attached; end
  def self.attached=(arg0); end
  def self.catchpoint_deleted_event; end
  def self.catchpoint_deleted_event=(arg0); end
  def self.cleanup_backtrace(backtrace); end
  def self.cli_debug; end
  def self.cli_debug=(arg0); end
  def self.control_thread; end
  def self.control_thread=(arg0); end
  def self.debug_program(options); end
  def self.debugger_memory_limit; end
  def self.debugger_memory_limit=(arg0); end
  def self.evaluation_timeout; end
  def self.evaluation_timeout=(arg0); end
  def self.find_free_port(host); end
  def self.inspect_time_limit; end
  def self.inspect_time_limit=(arg0); end
  def self.interface; end
  def self.interrupt_last; end
  def self.key_value_mode; end
  def self.key_value_mode=(arg0); end
  def self.notify_dispatcher_if_needed(host, port, need_notify); end
  def self.prepare_debugger(options); end
  def self.print_debug(*args); end
  def self.print_greeting_msg(stream, host, port, debugger_name = nil, socket_path = nil); end
  def self.run_prog_script; end
  def self.start_control(host, port, notify_dispatcher); end
  def self.start_control_unix(socket_path, notify_dispatcher); end
  def self.start_server(host = nil, port = nil, notify_dispatcher = nil); end
  def self.start_server_unix(socket_path, notify_dispatcher = nil); end
  def self.trace_to_s; end
  def self.trace_to_s=(arg0); end
  def self.value_as_nested_element; end
  def self.value_as_nested_element=(arg0); end
  def self.xml_debug; end
  def self.xml_debug=(arg0); end
end
class Debase::Interface
end
class Debase::LocalInterface < Debase::Interface
end
class Debase::RemoteInterface < Debase::Interface
  def close; end
  def command_queue; end
  def command_queue=(arg0); end
  def initialize(socket); end
  def non_blocking_gets; end
  def print(*args); end
  def read_command; end
end
module Debase::TimeoutHandler
  def self.do_thread_alias; end
  def self.undo_thread_alias; end
end
module Debase::ParseFunctions
  def get_int(str, cmd, min = nil, max = nil, default = nil); end
  def syntax_valid?(code); end
end
class Debase::VarConstantCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::VarGlobalCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::VarInstanceCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::VarLocalCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::JumpCommand < Debase::Command
  def execute; end
  def numeric?(object); end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::InspectCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.clear_references; end
  def self.reference_result(result); end
end
class Debase::QuitCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::RestartCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::StartCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::InterruptCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::DetachCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::EvalCommand < Debase::Command
  def execute; end
  def match(input); end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::PPCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::SetTypeCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ConditionCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ThreadListCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ThreadSwitchCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ThreadInspectCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ThreadStopCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ThreadCurrentCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ThreadResumeCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
module Debase::FrameFunctions
  def adjust_frame(frame_pos, absolute); end
end
class Debase::WhereCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::UpCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
  include Debase::FrameFunctions
end
class Debase::DownCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
  include Debase::FrameFunctions
end
class Debase::FrameCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
  include Debase::FrameFunctions
end
class Debase::AddBreakpoint < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::BreakpointsCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::DeleteBreakpointCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ExpressionInfoCommand < Debase::Command
  def create_io_reader(string_to_parse); end
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
module Debase::EnableDisableFunctions
  def enable_disable_breakpoints(is_enable, args); end
  def enable_disable_display(is_enable, args); end
end
class Debase::EnableCommand < Debase::Command
  def enable_breakpoints(args); end
  def enable_display(args); end
  def execute; end
  def regexp; end
  def self.help(args); end
  def self.help_command; end
end
class Debase::DisableCommand < Debase::Command
  def disable_breakpoints(args); end
  def disable_display(args); end
  def execute; end
  def regexp; end
  def self.help(args); end
  def self.help_command; end
end
class Debase::IncludeFile < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ExcludeFile < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::FileFilterCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::NextCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::StepCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::FinishCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::ContinueCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::PauseCommand < Debase::Command
  def execute; end
  def regexp; end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::LoadCommand < Debase::Command
  def execute; end
  def regexp; end
end
class Debase::CatchCommand < Debase::Command
  def clear_catchpoints; end
  def execute; end
  def regexp; end
  def remove_catchpoint(excn); end
  def self.help(cmd); end
  def self.help_command; end
end
class Debase::Command < SimpleDelegator
  def debug_eval(str, b = nil); end
  def debug_silent_eval(str); end
  def errmsg(*args); end
  def find(subcmds, param); end
  def get_binding; end
  def get_context(thnum); end
  def initialize(state, printer); end
  def line_at(file, line); end
  def match(input); end
  def print(*args); end
  def realpath(filename); end
  def self.commands; end
  def self.file_filter_supported?; end
  def self.inherited(klass); end
  def self.load_commands; end
  def self.method_missing(meth, *args, &block); end
  def self.options; end
  def self.unescape_incoming(str); end
  def timeout(sec); end
  include Debase::EnableDisableFunctions
  include Debase::FrameFunctions
  include Debase::ParseFunctions
end
class Debase::Command::SubcmdStruct < Struct
  def long_help; end
  def long_help=(_); end
  def min; end
  def min=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def short_help; end
  def short_help=(_); end
end
class Debase::IdeCommandProcessor
  def initialize(interface = nil); end
  def print(*args); end
  def process_commands; end
  def splitter; end
end
class Debase::IdeControlCommandProcessor < Debase::IdeCommandProcessor
  def process_commands; end
end
class Debase::State
  def binding; end
  def binding=(arg0); end
  def context; end
  def context=(arg0); end
  def file; end
  def file=(arg0); end
  def frame_pos; end
  def frame_pos=(arg0); end
  def initialize; end
  def interface; end
  def interface=(arg0); end
  def line; end
  def line=(arg0); end
  def original_context; end
  def original_context=(arg0); end
  def previous_line; end
  def previous_line=(arg0); end
  def print(*args); end
  def proceed; end
  def proceed?; end
  def restore_context; end
end
class Debase::ControlState
  def context; end
  def file; end
  def initialize(interface); end
  def print(*args); end
  def proceed; end
end
module Debase::OverflowMessageType
end
class Debase::ExecError
  def backtrace; end
  def initialize(message, backtrace = nil); end
  def message; end
end
class Debase::SimpleTimeLimitError < StandardError
  def initialize(message); end
  def message; end
end
class Debase::MemoryLimitError < Debase::ExecError
end
class Debase::TimeLimitError < Debase::ExecError
end
class Debase::XmlPrinter
  def __print_array(array); end
  def __print_at_line(context, file, line); end
  def __print_breakpoint(_, breakpoint); end
  def __print_breakpoint_added(b); end
  def __print_breakpoint_deleted(b); end
  def __print_breakpoint_disabled(b); end
  def __print_breakpoint_enabled(b); end
  def __print_breakpoints(breakpoints); end
  def __print_catchpoint(exception); end
  def __print_catchpoint_deleted(exception_class_name); end
  def __print_catchpoint_set(exception_class_name); end
  def __print_contdition_set(bp_id); end
  def __print_context(context); end
  def __print_contexts(contexts); end
  def __print_current_frame(frame_pos); end
  def __print_debug(*args); end
  def __print_element(name, additional_tags = nil); end
  def __print_error(*args); end
  def __print_eval(exp, value); end
  def __print_exception(exception, _); end
  def __print_expression(exp, value, idx); end
  def __print_expression_info(incomplete, prompt, indent); end
  def __print_expressions(exps); end
  def __print_file_excluded(file); end
  def __print_file_filter_status(status); end
  def __print_file_included(file); end
  def __print_frame(context, frame_id, current_frame_id); end
  def __print_frames(context, current_frame_id); end
  def __print_hash(hash); end
  def __print_inspect(eval_result); end
  def __print_list(b, e, file, line); end
  def __print_load_result(file, exception = nil); end
  def __print_methods(methods); end
  def __print_msg(*args); end
  def __print_pp(value); end
  def __print_string(string); end
  def __print_trace(context, file, line); end
  def __print_variable(name, value, kind); end
  def __print_variables(vars, kind); end
  def build_compact_name(value, value_str); end
  def build_compact_value_attr(value, value_str); end
  def build_value_attr(escaped_value_str); end
  def compact_array_str(value); end
  def compact_hash_str(value); end
  def current_thread_attr(context); end
  def do_print_hash(hash); end
  def do_print_hash_key_value(hash); end
  def exec_with_allocation_control(value, exec_method, overflow_message_type); end
  def exec_with_timeout(sec, error_message); end
  def handle_binary_data(value); end
  def initialize(interface); end
  def interface; end
  def interface=(arg0); end
  def max_compact_name_size; end
  def print(*params); end
  def print_array(*args, &block); end
  def print_at_line(*args, &block); end
  def print_breakpoint(*args, &block); end
  def print_breakpoint_added(*args, &block); end
  def print_breakpoint_deleted(*args, &block); end
  def print_breakpoint_disabled(*args, &block); end
  def print_breakpoint_enabled(*args, &block); end
  def print_breakpoints(*args, &block); end
  def print_catchpoint(*args, &block); end
  def print_catchpoint_deleted(*args, &block); end
  def print_catchpoint_set(*args, &block); end
  def print_contdition_set(*args, &block); end
  def print_context(*args, &block); end
  def print_contexts(*args, &block); end
  def print_current_frame(*args, &block); end
  def print_debug(*args, &block); end
  def print_element(*args, &block); end
  def print_error(*args, &block); end
  def print_eval(*args, &block); end
  def print_exception(*args, &block); end
  def print_expression(*args, &block); end
  def print_expression_info(*args, &block); end
  def print_expressions(*args, &block); end
  def print_file_excluded(*args, &block); end
  def print_file_filter_status(*args, &block); end
  def print_file_included(*args, &block); end
  def print_frame(*args, &block); end
  def print_frames(*args, &block); end
  def print_hash(*args, &block); end
  def print_inspect(*args, &block); end
  def print_list(*args, &block); end
  def print_load_result(*args, &block); end
  def print_methods(*args, &block); end
  def print_msg(*args, &block); end
  def print_pp(*args, &block); end
  def print_string(*args, &block); end
  def print_trace(*args, &block); end
  def print_variable(*args, &block); end
  def print_variables(*args, &block); end
  def safe_to_string(value); end
  def self.protect(mname); end
end
class Debase::XmlPrinter::ExceptionProxy
  def initialize(exception); end
  def method_missing(called, *args, &block); end
end
class Debase::EventProcessor
  def at_breakpoint(context, breakpoint); end
  def at_catchpoint(context, excpt); end
  def at_line(context, file, line); end
  def at_line?; end
  def at_return(context, file, line); end
  def at_tracing(context, file, line); end
  def context; end
  def context=(arg0); end
  def file; end
  def file=(arg0); end
  def initialize(interface); end
  def line; end
  def line=(arg0); end
  def line_event(context, file, line); end
end
class Debase::Exception
  def __debug_binding; end
  def __debug_context; end
  def __debug_file; end
  def __debug_line; end
end
