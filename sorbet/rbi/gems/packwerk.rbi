# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/packwerk/all/packwerk.rbi
#
# packwerk-1.1.1

module Packwerk
end
module Packwerk::OutputStyles
end
class Packwerk::OutputStyles::Plain
  def self.error; end
  def self.filename; end
  def self.reset; end
end
class Packwerk::OutputStyles::Coloured
  def self.error; end
  def self.filename; end
  def self.reset; end
end
class Packwerk::Offense
  def file; end
  def initialize(*args, &blk); end
  def location; end
  def message; end
  def to_s(*args, &blk); end
  extend T::Helpers
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Package
  def <=>(other); end
  def dependencies; end
  def dependency?(package); end
  def enforce_dependencies?; end
  def enforce_privacy; end
  def initialize(name:, config:); end
  def name; end
  def package_path?(path); end
  def public_path; end
  def public_path?(path); end
  def root?; end
  def to_s; end
  def user_defined_public_path; end
  include Comparable
end
class Packwerk::PackageSet
  def each(&blk); end
  def fetch(name); end
  def initialize(packages); end
  def package_from_path(file_path); end
  def self.create_root_package_if_none_in(packages); end
  def self.load_all_from(root_path, package_pathspec: nil); end
  def self.package_paths(root_path, package_pathspec); end
  include Enumerable
end
class Packwerk::Graph
  def acyclic?; end
  def add_cycle(cycle); end
  def cycles; end
  def initialize(*edges); end
  def neighbours(node); end
  def nodes; end
  def process; end
  def visit(node, visited_nodes: nil, path: nil); end
end
module Packwerk::Inflections
end
module Packwerk::Inflections::Default
  def self.apply_to(inflections_object); end
end
class Packwerk::Inflections::Custom
  def apply_to(inflections_object); end
  def inflections; end
  def inflections=(arg0); end
  def initialize(custom_inflection_file = nil); end
end
class Packwerk::Inflector
  def inflections(_ = nil); end
  def initialize(*args, &blk); end
  def pluralize(word, count = nil); end
  def self.default; end
  def self.from_file(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include ActiveSupport::Inflector
end
module Packwerk::ApplicationLoadPaths
  def self.assert_application_booted(*args, &blk); end
  def self.assert_load_paths_present(*args, &blk); end
  def self.extract_application_autoload_paths(*args, &blk); end
  def self.extract_relevant_paths(*args, &blk); end
  def self.filter_relevant_paths(*args, &blk); end
  def self.relative_path_strings(*args, &blk); end
end
class Packwerk::ApplicationValidator
  def check_acyclic_graph; end
  def check_all; end
  def check_application_structure; end
  def check_autoload_path_cache; end
  def check_inflection_file; end
  def check_package_manifest_paths; end
  def check_package_manifest_syntax; end
  def check_package_manifests_for_privacy; end
  def check_root_package_exists; end
  def check_valid_package_dependencies; end
  def format_yaml_strings(list); end
  def initialize(config_file_path:, configuration:); end
  def invalid_package_path?(path); end
  def package_glob; end
  def package_manifests(glob_pattern); end
  def package_manifests_settings_for(setting); end
  def relative_paths(paths); end
end
class Packwerk::ApplicationValidator::Result < Struct
  def error_value; end
  def error_value=(_); end
  def ok?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module Packwerk::ConstantNameInspector
  def constant_name_from_node(*args, &blk); end
  extend T::Helpers
  extend T::InterfaceWrapper::Helpers
  extend T::Private::Abstract::Hooks
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
module Packwerk::Node
  def self.class?(node); end
  def self.class_or_module_name(class_or_module_node); end
  def self.constant?(node); end
  def self.constant_assignment?(node); end
  def self.constant_name(constant_node); end
  def self.each_child(node); end
  def self.enclosing_namespace_path(starting_node, ancestors:); end
  def self.hash?(node); end
  def self.hash_pair_key(hash_pair_node); end
  def self.hash_pair_value(hash_pair_node); end
  def self.hash_pairs(hash_node); end
  def self.literal_value(string_or_symbol_node); end
  def self.location(node); end
  def self.method_arguments(method_call_node); end
  def self.method_call?(node); end
  def self.method_call_node(block_node); end
  def self.method_name(method_call_node); end
  def self.module_creation?(node); end
  def self.module_name_from_definition(node); end
  def self.name_from_block_definition(node); end
  def self.name_location(node); end
  def self.name_part_from_definition(node); end
  def self.parent_class(class_node); end
  def self.parent_module_name(ancestors:); end
  def self.receiver(method_call_or_block_node); end
  def self.string?(node); end
  def self.symbol?(node); end
  def self.type_of(node); end
  def self.value_from_hash(hash_node, key); end
end
class Packwerk::Node::TypeError < ArgumentError
end
class Packwerk::Node::Location < Struct
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Packwerk::AssociationInspector
  def association?(node); end
  def association_name(arguments); end
  def constant_name_from_node(node, ancestors:); end
  def custom_class_name(arguments); end
  def initialize(inflector:, custom_associations: nil); end
  include Packwerk::ConstantNameInspector
end
class Packwerk::Reference < Struct
  def constant; end
  def constant=(_); end
  def relative_path; end
  def relative_path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source_package; end
  def source_package=(_); end
end
class Packwerk::ViolationType < T::Enum
end
module Packwerk::ReferenceLister
  def listed?(*args, &blk); end
  extend T::Helpers
  extend T::InterfaceWrapper::Helpers
  extend T::Private::Abstract::Hooks
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::CheckingDeprecatedReferences
  def deprecated_references_file_for(package); end
  def deprecated_references_for(source_package); end
  def initialize(root_path); end
  def listed?(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::ReferenceLister
end
class Packwerk::Configuration
  def config_path; end
  def custom_associations; end
  def exclude; end
  def include; end
  def inflections_file; end
  def initialize(configs = nil, config_path: nil); end
  def load_paths; end
  def package_paths; end
  def root_path; end
  def self.from_packwerk_config(path); end
  def self.from_path(path = nil); end
end
class Packwerk::FilesForProcessing
  def configured_excluded_files; end
  def configured_included_files; end
  def custom_files; end
  def custom_included_files(path); end
  def files; end
  def files_for_globs(globs); end
  def initialize(paths, configuration); end
  def self.fetch(paths:, configuration:); end
end
module Packwerk::Formatters
end
class Packwerk::Formatters::OffensesFormatter
  def initialize(*args, &blk); end
  def offenses_list(*args, &blk); end
  def offenses_summary(*args, &blk); end
  def show_offenses(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Formatters::ProgressFormatter
  def finished(execution_time); end
  def initialize(out, style: nil); end
  def mark_as_failed; end
  def mark_as_inspected; end
  def started(target_files); end
  def started_validation; end
end
class Packwerk::ConstantDiscovery
  def context_for(const_name, current_namespace_path: nil); end
  def initialize(constant_resolver:, packages:); end
  def package_from_path(path); end
end
class Packwerk::ConstantDiscovery::ConstantContext < Struct
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def package; end
  def package=(_); end
  def public?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Packwerk::ConstNodeInspector
  def constant_in_module_or_class_definition?(node, parent:); end
  def constant_name_from_node(node, ancestors:); end
  def fully_qualify_constant(node, ancestors:); end
  def generate_qualified_constant(node, ancestors:); end
  def root_constant?(parent); end
  include Packwerk::ConstantNameInspector
end
module Packwerk::Checker
  def invalid_reference?(*args, &blk); end
  def message_for(*args, &blk); end
  extend T::Helpers
  extend T::InterfaceWrapper::Helpers
  extend T::Private::Abstract::Hooks
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::DependencyChecker
  def invalid_reference?(reference, reference_lister); end
  def message_for(reference); end
  def violation_type; end
  include Packwerk::Checker
end
module Packwerk::Parsers
end
class Packwerk::Parsers::ParseResult < Packwerk::Offense
end
class Packwerk::Parsers::ParseError < StandardError
  def initialize(result); end
  def result; end
end
class Packwerk::FileProcessor
  def call(file_path); end
  def initialize(node_processor_factory:, parser_factory: nil); end
end
class Packwerk::FileProcessor::UnknownFileTypeResult < Packwerk::Offense
  def initialize(file:); end
end
class Packwerk::PrivacyChecker
  def enforcement_disabled?(privacy_option); end
  def explicitly_private_constant?(constant, explicitly_private_constants:); end
  def invalid_reference?(reference, reference_lister); end
  def message_for(reference); end
  def violation_type; end
  include Packwerk::Checker
end
class Packwerk::ParsedConstantDefinitions
  def add_definition(constant_name, current_namespace_path, location); end
  def collect_local_definitions_from_root(node, current_namespace_path = nil); end
  def initialize(root_node:); end
  def local_reference?(constant_name, location: nil, namespace_path: nil); end
  def self.reference_qualifications(constant_name, namespace_path:); end
end
class Packwerk::ReferenceExtractor
  def initialize(*args, &blk); end
  def local_reference?(constant_name, name_location, namespace_path); end
  def reference_from_constant(constant_name, node:, ancestors:, file_path:); end
  def reference_from_node(node, ancestors:, file_path:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::NodeProcessorFactory < T::Struct
  def __t_props_generated_deserialize(*args); end
  def __t_props_generated_serialize(*args); end
  def checkers; end
  def constant_name_inspectors; end
  def context_provider; end
  def for(*args, &blk); end
  def reference_extractor(*args, &blk); end
  def reference_lister; end
  def root_path; end
  def self.inherited(s); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Props::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Serializable::ClassMethods
  extend T::Sig
end
class Packwerk::RunContext
  def checker_classes; end
  def checkers(*args, &blk); end
  def constant_name_inspectors(*args, &blk); end
  def context_provider(*args, &blk); end
  def custom_associations; end
  def file_processor(*args, &blk); end
  def inflector; end
  def initialize(root_path:, load_paths:, reference_lister:, package_paths: nil, inflector: nil, custom_associations: nil, checker_classes: nil); end
  def load_paths; end
  def node_processor_factory(*args, &blk); end
  def package_paths; end
  def package_set(*args, &blk); end
  def process_file(*args, &blk); end
  def reference_lister; end
  def reference_lister=(arg0); end
  def resolver(*args, &blk); end
  def root_path; end
  def self.from_configuration(configuration, reference_lister:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::DeprecatedReferences
  def add_entries(reference, violation_type); end
  def deprecated_references; end
  def dump; end
  def initialize(package, filepath); end
  def listed?(*args, &blk); end
  def prepare_entries_for_dump; end
  def stale_violations?(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::ReferenceLister
end
class Packwerk::CacheDeprecatedReferences
  def deprecated_references_file_for(package); end
  def deprecated_references_for(package); end
  def initialize(root_path, deprecated_references = nil); end
  def listed?(*args, &blk); end
  extend T::Helpers
  extend T::InterfaceWrapper::Helpers
  extend T::Private::Abstract::Hooks
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::ReferenceLister
end
class Packwerk::UpdatingDeprecatedReferences < Packwerk::CacheDeprecatedReferences
  def dump_deprecated_references_files; end
end
class Packwerk::DetectStaleDeprecatedReferences < Packwerk::CacheDeprecatedReferences
  def stale_violations?(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
module Packwerk::OffenseProgressMarker
  def mark_progress(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
module Packwerk::Commands
end
class Packwerk::Commands::Result < T::Struct
  def __t_props_generated_deserialize(*args); end
  def __t_props_generated_serialize(*args); end
  def message; end
  def message=(val); end
  def self.inherited(s); end
  def status; end
  def status=(val); end
  extend T::Props::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Plugin::ClassMethods
  extend T::Props::Serializable::ClassMethods
end
class Packwerk::Commands::DetectStaleViolationsCommand
  def calculate_result(*args, &blk); end
  def initialize(files:, configuration:, run_context: nil, progress_formatter: nil, reference_lister: nil); end
  def reference_lister; end
  def run(*args, &blk); end
  def run_context; end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::OffenseProgressMarker
end
class Packwerk::Commands::UpdateDeprecationsCommand
  def calculate_result(*args, &blk); end
  def initialize(*args, &blk); end
  def run(*args, &blk); end
  def run_context(*args, &blk); end
  def updating_deprecated_references(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::OffenseProgressMarker
end
class Packwerk::Cli
  def check(paths); end
  def detect_stale_violations(paths); end
  def execute_command(*args, &blk); end
  def fetch_files_to_process(paths); end
  def generate_configs; end
  def init; end
  def initialize(run_context: nil, configuration: nil, out: nil, err_out: nil, style: nil); end
  def list_validation_errors(result); end
  def offenses_formatter; end
  def rails_app?(*args, &blk); end
  def run(*args, &blk); end
  def update(paths); end
  def update_deprecations(paths); end
  def validate(_paths); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::OffenseProgressMarker
end
module Packwerk::Generators
end
class Packwerk::Generators::ApplicationValidation
  def generate(for_rails_app:); end
  def generate_packwerk_validate_script; end
  def generate_validation_test; end
  def initialize(root, out: nil); end
  def self.generate(for_rails_app: nil, root: nil, out: nil); end
end
class Packwerk::Generators::ConfigurationFile
  def generate(*args, &blk); end
  def initialize(*args, &blk); end
  def render; end
  def self.generate(load_paths:, root:, out:); end
  def set_template_variables; end
  def template; end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Generators::InflectionsFile
  def generate(*args, &blk); end
  def initialize(root, out: nil); end
  def self.generate(root:, out:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Generators::RootPackage
  def generate(*args, &blk); end
  def initialize(root:, out: nil); end
  def self.generate(root:, out:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::NodeProcessor
  def call(node, ancestors:); end
  def check_reference(reference, node); end
  def failed_check(reference); end
  def initialize(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::NodeVisitor
  def initialize(node_processor:); end
  def visit(node, ancestors:, result:); end
end
